import json
import time
import random
from rich.console import Console
from rich.layout import Layout
from rich.panel import Panel
from rich.table import Table
from rich.live import Live
from rich.text import Text

# --- 1. The Digital Twin Engine ---
# This class contains the core logic and mathematical models for the simulation.
class DataCenterTwin:
    """
    The core engine for the Data Center Digital Twin.
    It simulates the thermal and energy dynamics based on input parameters.
    """
    def __init__(self):
        # Configuration constants for the simulation model.
        # These would be tuned based on real-world data from the specific data center.
        self.SERVER_MAX_POWER_WATTS = 1500
        self.SERVER_IDLE_POWER_WATTS = 150
        self.HEAT_DISSIPATION_FACTOR = 0.01  # How much temp increases per watt of server power
        self.COOLING_BASE_POWER_WATTS = 500 # Power consumed by cooling at minimum load
        self.COOLING_EFFICIENCY_FACTOR = 1.2 # How much extra power is needed to counter heat
        self.AMBIENT_TEMP_IMPACT_FACTOR = 15 # Extra watts per degree above ideal ambient temp
        self.IDEAL_AMBIENT_TEMP_C = 20.0
        self.TARGET_OUTLET_TEMP_C = 28.0
        self.COST_PER_KWH_USD = 0.12

    def simulate_step(self, server_workload_percent, inlet_temp_c, ambient_temp_c):
        """
        Runs a single simulation step.

        Args:
            server_workload_percent (float): The current server workload (0-100).
            inlet_temp_c (float): The current temperature of air entering the servers.
            ambient_temp_c (float): The temperature of the room outside the racks.

        Returns:
            dict: A dictionary containing all calculated output parameters.
        """

        # --- Mathematical Models ---

        # 1. Calculate Server Power based on workload
        # A linear model: Power = IdlePower + (Workload % * (MaxPower - IdlePower))
        server_power_watts = self.SERVER_IDLE_POWER_WATTS + \
                             (server_workload_percent / 100) * (self.SERVER_MAX_POWER_WATTS - self.SERVER_IDLE_POWER_WATTS)

        # 2. Calculate Outlet Temperature
        # Outlet = Inlet + Heat generated by servers
        heat_generated = server_power_watts * self.HEAT_DISSIPATION_FACTOR
        outlet_temp_c = inlet_temp_c + heat_generated

        # 3. Calculate Cooling Unit Power
        # Power needed to remove the generated heat, plus extra for ambient conditions.
        cooling_power_for_heat = heat_generated * self.COOLING_EFFICIENCY_FACTOR
        cooling_power_for_ambient = max(0, (ambient_temp_c - self.IDEAL_AMBIENT_TEMP_C)) * self.AMBIENT_TEMP_IMPACT_FACTOR
        cooling_unit_power_watts = self.COOLING_BASE_POWER_WATTS + cooling_power_for_heat + cooling_power_for_ambient

        # 4. Calculate PUE (Power Usage Effectiveness)
        # PUE = Total Power / IT Power
        total_power_watts = server_power_watts + cooling_unit_power_watts
        pue = total_power_watts / server_power_watts if server_power_watts > 0 else 0

        # 5. Calculate Chiller and AHU Usage (as a percentage of cooling power)
        # This is a simplified model where they share the cooling load.
        chiller_usage_percent = (cooling_unit_power_watts / (self.COOLING_BASE_POWER_WATTS + (self.SERVER_MAX_POWER_WATTS * self.HEAT_DISSIPATION_FACTOR * self.COOLING_EFFICIENCY_FACTOR) + 500)) * 100
        ahu_usage_percent = chiller_usage_percent * random.uniform(0.6, 0.8) # AHU often works less than the chiller

        # 6. Calculate Energy Cost
        # Cost for one hour of operation at current total power.
        total_power_kw = total_power_watts / 1000
        total_energy_cost_usd = total_power_kw * self.COST_PER_KWH_USD

        # 7. Calculate Temperature Deviation from target
        temp_deviation_c = outlet_temp_c - self.TARGET_OUTLET_TEMP_C

        # --- Logic for Decision Making ---

        # 8. Determine Cooling Strategy based on the outputs
        cooling_strategy = self._get_cooling_strategy(temp_deviation_c, pue)

        return {
            "calculated_server_power_watts": server_power_watts,
            "outlet_temp_c": outlet_temp_c,
            "cooling_unit_power_watts": cooling_unit_power_watts,
            "calculated_pue": pue,
            "chiller_usage_percent": min(100, chiller_usage_percent),
            "ahu_usage_percent": min(100, ahu_usage_percent),
            "total_energy_cost_usd": total_energy_cost_usd,
            "temp_deviation_c": temp_deviation_c,
            "cooling_strategy": cooling_strategy,
        }

    def _get_cooling_strategy(self, temp_deviation, pue):
        """A simple rule-based system for cooling decisions."""
        if temp_deviation > 2.0:
            return "[bold red]CRITICAL: Boost All Cooling[/bold red]"
        elif temp_deviation > 0.5:
            return "[bold yellow]WARNING: Increase Cooling[/bold yellow]"
        elif pue > 1.8:
            return "[bold yellow]EFFICIENCY ALERT: Optimize Cooling[/bold yellow]"
        else:
            return "[bold green]STABLE: Monitor[/bold green]"

# --- 2. The Dashboard UI ---
def generate_dashboard(input_data, output_data):
    """Generates the rich layout for the dashboard."""
    layout = Layout()
    layout.split(
        Layout(name="header", size=3),
        Layout(ratio=1, name="main"),
        Layout(size=5, name="footer"),
    )

    layout["main"].split_row(Layout(name="left"), Layout(name="right"))

    # Header
    header_text = Text("Data Center Digital Twin Dashboard", style="bold white on blue", justify="center")
    layout["header"].update(header_text)
    
    # Footer (Cooling Strategy)
    strategy = output_data.get('cooling_strategy', 'N/A')
    layout["footer"].update(Panel(Text(strategy, justify="center"), title="[bold]Recommended Cooling Strategy[/bold]", border_style="blue"))


    # Left Panel: Input Parameters
    input_table = Table(title="Input Parameters", show_header=False, border_style="cyan")
    input_table.add_column("Parameter", style="dim")
    input_table.add_column("Value")
    
    # Safely access nested dictionary keys
    entity_id = input_data.get('meta_data', {}).get('entityId', 'Initializing...')
    timestamp = input_data.get('meta_data', {}).get('timestamp', '...')
    workload = input_data.get('payload', {}).get('server_workload_percent')
    inlet_temp = input_data.get('payload', {}).get('inlet_temp_c')
    ambient_temp = input_data.get('payload', {}).get('ambient_temp_c')

    input_table.add_row("Entity ID", str(entity_id))
    input_table.add_row("Timestamp", str(timestamp))
    input_table.add_row("Server Workload", f"{workload:.2f} %" if workload is not None else "...")
    input_table.add_row("Inlet Temperature", f"{inlet_temp:.2f} 째C" if inlet_temp is not None else "...")
    input_table.add_row("Ambient Temperature", f"{ambient_temp:.2f} 째C" if ambient_temp is not None else "...")
    layout["left"].update(Panel(input_table, title="[bold]Simulation Inputs[/bold]", border_style="cyan"))

    # Right Panel: Real-time Metrics
    output_table = Table(title="Real-time Metrics", show_header=False, border_style="magenta")
    output_table.add_column("Metric", style="dim")
    output_table.add_column("Value")

    # Safely access output data keys and provide defaults
    calculated_pue = output_data.get('calculated_pue', 0)
    temp_deviation = output_data.get('temp_deviation_c', 0)
    outlet_temp = output_data.get('outlet_temp_c')
    server_power = output_data.get('calculated_server_power_watts')
    cooling_power = output_data.get('cooling_unit_power_watts')
    chiller_usage = output_data.get('chiller_usage_percent')
    ahu_usage = output_data.get('ahu_usage_percent')
    energy_cost = output_data.get('total_energy_cost_usd')

    # Add color coding for critical metrics
    pue_style = "green" if calculated_pue < 1.6 else "yellow" if calculated_pue < 1.9 else "red"
    temp_dev_style = "green" if temp_deviation <= 0.5 else "yellow" if temp_deviation < 2.0 else "red"

    output_table.add_row("Outlet Temperature", f"{outlet_temp:.2f} 째C" if outlet_temp is not None else "...")
    output_table.add_row("Temp Deviation", f"[{temp_dev_style}]{temp_deviation:.2f} 째C[/{temp_dev_style}]")
    output_table.add_row("Server Power", f"{server_power:.2f} W" if server_power is not None else "...")
    output_table.add_row("Cooling Power", f"{cooling_power:.2f} W" if cooling_power is not None else "...")
    output_table.add_row("PUE", f"[{pue_style}]{calculated_pue:.2f}[/{pue_style}]")
    output_table.add_row("Chiller Usage", f"{chiller_usage:.2f} %" if chiller_usage is not None else "...")
    output_table.add_row("AHU Usage", f"{ahu_usage:.2f} %" if ahu_usage is not None else "...")
    output_table.add_row("Hourly Energy Cost", f"$ {energy_cost:.2f}" if energy_cost is not None else "...")
    layout["right"].update(Panel(output_table, title="[bold]Twin Outputs[/bold]", border_style="magenta"))

    return layout

# --- 3. Main Application Logic ---
if __name__ == "__main__":
    console = Console()

    # Instantiate the engine
    twin_engine = DataCenterTwin()

    # Load the dataset
    try:
        with open('datacenter_final_structured_output.json', 'r') as f:
            simulation_data = json.load(f)
    except FileNotFoundError:
        console.print("[bold red]Error: 'datacenter_final_structured_output.json' not found.[/bold red]")
        console.print("Please make sure the JSON file is in the same directory as this script.")
        exit()

    # Run the simulation loop
    console.print("[green]Starting Digital Twin Simulation... Press Ctrl+C to exit.[/green]")
    time.sleep(2)

    with Live(generate_dashboard({}, {}), screen=True, redirect_stderr=False, refresh_per_second=1) as live:
        try:
            for data_point in simulation_data:
                # Get inputs from the loaded data
                payload = data_point['payload']
                workload = payload['server_workload_percent']
                inlet_temp = payload['inlet_temp_c']
                ambient_temp = payload['ambient_temp_c']

                # Run the engine to get the simulated outputs
                results = twin_engine.simulate_step(workload, inlet_temp, ambient_temp)

                # Update the dashboard with the new data
                live.update(generate_dashboard(data_point, results))

                # Wait for a moment to simulate real-time updates
                time.sleep(1.5)
        except KeyboardInterrupt:
            console.print("\n[bold]Simulation stopped by user.[/bold]")

